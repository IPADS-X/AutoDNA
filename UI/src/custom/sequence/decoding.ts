export const decoding_chat = [
    {
        role: "user",
        content: "生成解码方案。",
    },
    {
        role: "assistant",
        content: "为了解码给定的编码方案，我们需要逆转编码过程中每个步骤的操作。以下是一个解码方案的实现：\n\n```python\ndef ternary_to_sequence_number(ternary_digits):\n    n = 0\n    for digit in ternary_digits:\n        n = n * 3 + digit\n    return n\n\ndef decode_part(encoded_str, prev_nuc=None, is_start=False):\n    decoded_digits = []\n    current_prev = prev_nuc\n    for i, nuc in enumerate(encoded_str):\n        if i == 0 and is_start:\n            # Initial mapping\n            if nuc == 'A':\n                digit = 0\n            elif nuc == 'T':\n                digit = 1\n            elif nuc == 'C':\n                digit = 2\n            else:\n                raise ValueError(f\"Invalid nucleotide {nuc} in initial mapping\")\n        else:\n            if current_prev is None:\n                raise ValueError(\"Previous nucleotide is None for non-start part\")\n            reverse_map = {\n                'A': {'T': 0, 'C': 1, 'G': 2},\n                'T': {'A': 0, 'C': 1, 'G': 2},\n                'C': {'A': 0, 'T': 1, 'G': 2},\n                'G': {'A': 0, 'T': 1, 'C': 2},\n            }\n            digit = reverse_map[current_prev][nuc]\n        decoded_digits.append(digit)\n        current_prev = nuc\n    return decoded_digits, current_prev\n\ndef decode_strand(encoded_strand):\n    # Decode S part\n    s_part, last_nuc = decode_part(encoded_strand[:4], is_start=True)\n    # Decode D part\n    d_part, last_nuc = decode_part(encoded_strand[4:-1], prev_nuc=last_nuc, is_start=False)\n    # Decode E part\n    e_part, _ = decode_part(encoded_strand[-1:], prev_nuc=last_nuc, is_start=False)\n    return s_part, d_part, e_part\n\ndef ternary_chunks_to_text(chunks):\n    binary_str = ''\n    for chunk in chunks:\n        binary_val = 0\n        for digit in chunk:\n            binary_val = binary_val * 3 + digit\n        binary_str += format(binary_val, '08b')\n    ascii_bytes = int(binary_str, 2).to_bytes((len(binary_str) + 7) // 8, byteorder='big')\n    return ascii_bytes.decode('ascii').rstrip('\x00')\n\ndef main():\n    encoded_strands = [\n        \"ATATATACATACATACATAGATAGATCATATCATCTATAGATCGATATATGATATGATGTATATATGCATACACATATAC\",\n        # Add other strands here\n    ]\n    \n    chunks = []\n    for i, strand in enumerate(encoded_strands):\n        s_digits, d_digits, e_digit = decode_strand(strand)\n        if compute_error_check(s_digits, d_digits) != e_digit[0]:\n            raise ValueError(f\"Error check failed for strand {i}\")\n        chunks.append(d_digits)\n    \n    text = ternary_chunks_to_text(chunks)\n    print(text)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### 解码步骤：\n\n1. **解码 S 部分**：使用 `decode_part` 函数，从编码的核苷酸序列中提取 S 部分的三进制数字。\n\n2. **解码 D 部分**：从编码序列中提取 D 部分的三进制数字。\n\n3. **解码 E 部分**：提取 E 部分，用于错误检查。\n\n4. **错误检查**：使用 `compute_error_check` 函数验证解码是否正确。\n\n5. **组合成文本**：将所有 D 部分组合成一个完整的二进制字符串，并转换回 ASCII 文本。\n\n执行上述代码即可完成解码过程。",
    }
]

export const decoding_step = "子任务：生成解码方案";