export const encoding_chat = [
    {
        role: "user",
        content: "从编码库中生成一个编码方案，能够保证编码的唯一性，同时也能够保证编码的可读性。",
    },
    {
        role: "assistant",
        content: "好的，我从编码库中找到了如下编码方案：\n```python\ndef text_to_ternary_chunks(text):\n    ascii_bytes = text.encode(\'ascii\')\n    binary_str = \'\'.join(format(b, \'08b\') for b in ascii_bytes)\n    binary_val = int(binary_str, 2)\n    \n    # Convert to base3 digits (MSB first)\n    digits = []\n    n = binary_val\n    if n == 0:\n        digits.append(0)\n    else:\n        while n > 0:\n            digits.append(n % 3)\n            n = n // 3\n    digits = digits[::-1]  # MSB first\n    \n    # Pad with one zero and ensure length is 234\n    digits.append(0)\n    while len(digits) < 234:\n        digits.append(0)\n    \n    # Split into chunks\n    chunks = [digits[i*3 : (i+1)*3] for i in range(78)]\n    return chunks\n\ndef sequence_number_to_ternary(n):\n    digits = []\n    for _ in range(4):\n        digits.append(n % 3)\n        n = n // 3\n    digits = digits[::-1]\n    return digits\n\ndef compute_error_check(s_digits, d_digits):\n    total = sum(s_digits) + sum(d_digits)\n    return total % 3\n\ndef encode_part(digits, prev_nuc=None, is_start=False):\n    encoded = []\n    current_prev = prev_nuc\n    for i, digit in enumerate(digits):\n        if i == 0 and is_start:\n            # Initial mapping\n            if digit == 0:\n                nuc = \'A\'\n            elif digit == 1:\n                nuc = \'T\'\n            elif digit == 2:\n                nuc = \'C\'\n            else:\n                raise ValueError(f\"Invalid digit {digit} in initial mapping\")\n        else:\n            if current_prev is None:\n                raise ValueError(\"Previous nucleotide is None for non-start part\")\n            transition_map = {\n                \'A\': {0: \'T\', 1: \'C\', 2: \'G\'},\n                \'T\': {0: \'A\', 1: \'C\', 2: \'G\'},\n                \'C\': {0: \'A\', 1: \'T\', 2: \'G\'},\n                \'G\': {0: \'A\', 1: \'T\', 2: \'C\'},\n            }\n            nuc = transition_map[current_prev][digit]\n        encoded.append(nuc)\n        current_prev = nuc\n    return \'\'.join(encoded), current_prev\n\ndef encode_strand(s_digits, d_digits, e_digit):\n    # Encode S part\n    s_part, last_nuc = encode_part(s_digits, is_start=True)\n    # Encode D part\n    d_part, last_nuc = encode_part(d_digits, prev_nuc=last_nuc, is_start=False)\n    # Encode E part\n    e_part, _ = encode_part([e_digit], prev_nuc=last_nuc, is_start=False)\n    return s_part + d_part + e_part\n\ndef main():\n    text = \"\"\n    chunks = text_to_ternary_chunks(text)\n    for i in range(78):\n        s_digits = sequence_number_to_ternary(i)\n        d_digits = chunks[i]\n        e_digit = compute_error_check(s_digits, d_digits)\n        strand = encode_strand(s_digits, d_digits, e_digit)\n        print(strand)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n# 运行上述代码，可以得到编码序列为：\nATATATATATACATACATAGATAGATCATATCATCTATAGATCGATATATGATATGATGTATATATGCATACACATATACACACATAGACAGATATACTATATGACTCATATACTGATACACGATATAACGTATACACGCATAGAGATATAGAGACATATAGAGATACAGTATATAAGTCATACAGTGATAGAGCATATCAGCTATAGAGCGATATTATATATCTATCATAGTATGATATTACATATGTACTATATTACGATACTAGATATATAGTATACTAGCATAGTCATATAGTCACATATTCAGATACTCTATATATCTCATACTCTGATAGTCGATATCTCGTATAGTCGCATATTGATATATTGACATACTGAGATAGTGTATATCTGTCATAGTGTGATATTGCATATGTGCTATATTGCGATACCATATATGCATCATATCATGATACCACATATACACTATACCACGATAGCAGATATCCAGTACTCCAGCTATCCTATCACGCTACACGTCTAGAGCACTCATGTCCTCTCGTACTCGACACCTGAGACGCTGTCTAGCTGCTATGCGATGCAGCGACGTCACGAGCGCACGTATATGCGTCACACCGTGATGA",
    }
]

export const encoding_step = "子任务：生成编码方案并生成编码";